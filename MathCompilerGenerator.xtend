/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.HashMap
import org.xtext.example.mydsl.mathCompiler.Expression
import java.util.Map
import org.xtext.example.mydsl.mathCompiler.Plus
import org.xtext.example.mydsl.mathCompiler.Minus
import org.xtext.example.mydsl.mathCompiler.Mult
import org.xtext.example.mydsl.mathCompiler.Div
import org.xtext.example.mydsl.mathCompiler.Num
import org.xtext.example.mydsl.mathCompiler.Var
import org.xtext.example.mydsl.mathCompiler.Let
import org.eclipse.xtend2.lib.StringConcatenation
import org.xtext.example.mydsl.mathCompiler.MathExp

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathCompilerGenerator extends AbstractGenerator {

	StringConcatenation stringCon;
	StringConcatenation methodCon;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		generateFile(fsa, math);		
	}
	
	
	def generateFile(IFileSystemAccess2 fsa, MathExp exp){
		fsa.generateFile("MathComputation.java", generateCharSequence(exp));
	}
	
	def CharSequence generateCharSequence(MathExp exp){
	    stringCon = new StringConcatenation();
	    stringCon.append(generateImports)
	    stringCon.newLineIfNotEmpty
	    stringCon.newLine
	    stringCon.append("public class MathComputation {")
	    stringCon.newLineIfNotEmpty
	    stringCon.append(generateConstructor)
	    stringCon.newLineIfNotEmpty
		stringCon.append(generateMethod(exp))
	    stringCon.newLineIfNotEmpty
		stringCon.append("}")
		return stringCon
	}
	
	def CharSequence generateImports(){
		return '''
		
		import java.util.*;
		'''
	}
	
	def CharSequence generateConstructor(){
		return '''
				
			public MathComputation() {
				
			}
		'''
	}
	
	def CharSequence generateMethod(MathExp exp){
		return '''
		
			public void compute() {
				«FOR _exp:exp.output»
				System.out.println("«_exp.string» is: " + («_exp.exp.displayExp»));
				«ENDFOR»
			}
		'''
		
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def int compute(MathExp math) {
		//math.exp.computeExp(new HashMap<String,Integer>)
		return 0
	}
	
	def int computeExp(Expression exp, Map<String,Integer> env) {
		switch exp {
			Plus: exp.left.computeExp(env)+exp.right.computeExp(env)
			Minus: exp.left.computeExp(env)-exp.right.computeExp(env)
			Mult: exp.left.computeExp(env)*exp.right.computeExp(env)
			Div: exp.left.computeExp(env)/exp.right.computeExp(env)
			Num: exp.value
			Var: env.get(exp.id)
			Let: exp.body.computeExp(env.bind(exp.id,exp.binding.computeExp(env)))
			default: throw new Error("Invalid expression")
		}
	}
	
	def Map<String, Integer> bind(Map<String, Integer> env1, String name, int value) {
		val env2 = new HashMap<String,Integer>(env1)
		env2.put(name,value)
		env2 
	}

	def String display(MathExp math) { 
		//return math.exp.displayExp
		return ""
	}
	
	def String displayExp(Expression exp) {
		""+switch exp {
			Plus: exp.left.displayExp+"+"+exp.right.displayExp
			Minus: exp.left.displayExp+"-"+exp.right.displayExp
			Mult: exp.left.displayExp+"*"+exp.right.displayExp
			Div: exp.left.displayExp+"/"+exp.right.displayExp
			Num: Integer.toString(exp.value)
			Var: exp.id
			Let: '''let «exp.id» = «exp.binding.displayExp» in «exp.body.displayExp» end'''
			default: throw new Error("Invalid expression")
		}+""
	}
	
		
}
